using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.VisualStudio.TestTools.UnitTesting;

using VerifyCS = AutoInvoke.Generator.UnitTests.Verifiers.CSharpSourceGeneratorVerifier<AutoInvoke.Generator.InvokeGenerator>;

namespace AutoInvoke.Generator.UnitTests;
[TestClass]
public class HelloWorldGeneratorUnitTests {
    private const string CallForEnum = """
// <auto-generated/>
#nullable enable

namespace AutoInvoke;
[System.Flags]
internal enum CallFor
{
    None = 0,
    AbstractClass = 1 << 0,
    Interface = 1 << 1,
    Struct = 1 << 2,
    Class = 1 << 3,
    RecordClass = 1 << 4,
    Enum = 1 << 5,
    RecordStruct = 1 << 6,
    AbstractTypes = AbstractClass | Interface,
    All = AbstractClass | Interface | Struct | Class | RecordClass | RecordStruct | Enum,
    NonAbstractTypes = Struct | Class | Enum | RecordStruct | RecordClass,
}
""";


    private const string CallForAttribute = """
// <auto-generated/>
#nullable enable

namespace AutoInvoke;
[System.AttributeUsage(System.AttributeTargets.GenericParameter, Inherited = false, AllowMultiple = false)]
internal sealed class CallForAttribute : System.Attribute
{
    // This is a positional argument
    public CallForAttribute(CallFor callFor)
    {
        this.CallFor = callFor;
    }

    /// <summary>
    /// Specifies what kind of types this attribute applies to.
    /// </summary>
    public CallFor CallFor { get; }
    // This is a named argument
    /// <summary>
    /// The pattern to match the type name against.
    /// </summary>
    public string[]? Pattern { get; set; }
}
""";
    private const string Attribute = """
// <auto-generated/>
#nullable enable

namespace AutoInvoke;
[System.AttributeUsage(System.AttributeTargets.Method, Inherited = false, AllowMultiple = false)]
[System.Diagnostics.Conditional("AutoNotifyGenerator_DEBUG")]
internal sealed class FindAndInvokeAttribute : System.Attribute
{
#pragma warning disable CS0169 // Remove unused parameter

#pragma warning disable IDE0060 // Remove unused parameter

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

    public FindAndInvokeAttribute()
    {
    }

    public FindAndInvokeAttribute(string pattern)
    {
    }

    public bool ScanExternalAssamblies { get; set; }
    /// <summary>
    /// The name of the generated method.
    /// </summary>
    public string MethodName { get; set; }
#pragma warning restore CS0169 // Remove unused parameter

#pragma warning restore IDE0060 // Remove unused parameter

#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

}
""";

    private readonly (string, string)[] stdAttrributes = [ ("attribute.g.cs", Attribute),
            ("CallFor.g.cs", CallForEnum),
            ("attributeCallFor.g.cs", CallForAttribute)];

    [TestMethod]
    public async Task GenerateSimple() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter {
	[AutoInvoke.FindAndInvoke(ScanExternalAssamblies=true)]
	public static void GetHelloWorld<T>() where T : Foo {
		
	}
}

class Foo {}
class Bar {}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Foo>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    } 
    [TestMethod]
    public async Task GenerateForInterfaceWithImplementation() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter {
	[AutoInvoke.FindAndInvoke]
    public static void GetHelloWorld<[AutoInvoke.CallFor(AutoInvoke.CallFor.Interface)] TInterface, TImplementation>() where TInterface : IBar<TImplementation> where TImplementation : TInterface {
	
	}
}

interface IBar<T> where T :IBar<T> {}
interface IFoo : IBar<Foo>{}
class Foo:IFoo {}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.IFoo, global::T1.T2.Foo>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }
    [TestMethod]
    public async Task GenerateSynchron() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter {
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>() where T : Foo {
		
	}
}

class Foo {}
class Bar :Foo {}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Foo>();
        GetHelloWorld<global::T1.T2.Bar>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }

    [TestMethod]
    public async Task GenerateAsync() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static System.Threading.Tasks.Task GetHelloWorld<T>() where T : Foo {
		return System.Threading.Tasks.Task.CompletedTask;
	}
}

class Foo {}
class Bar :Foo {}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static global::System.Threading.Tasks.Task[] GetHelloWorld() {
        return new [] {
            GetHelloWorld<global::T1.T2.Foo>(),
            GetHelloWorld<global::T1.T2.Bar>()
        };
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }

    [TestMethod]
    public async Task DoNotGenerateAbstract() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>() where T : Foo {
		
	}
}

abstract class Foo {}
class Bar : Foo{}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Bar>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }
    [TestMethod]
    public async Task DoNotGenerateStatic() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>() {
		
	}
}

static class Foo {}
class Bar {}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Bar>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }

    [TestMethod]
    public async Task SelfReferecningGeneric() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>() where T : Foo<T> {
		
	}
}

interface Foo<TData> where TData : Foo<TData> {}
class Bar : Foo<Bar> {}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Bar>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }
    [TestMethod]
    public async Task SelfReferecningNestedGeneric() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>() where T : Foo<Bar<T>> {
		
	}
}

interface Foo<TData>{}
interface Bar<TData2> {}
class My : Foo<Bar<My>> {}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.My>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }

    [TestMethod]
    public async Task BoundGeneric() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>() where T : Foo<string> {
		
	}
}

interface Foo<TData>  {}
class Bar : Foo<string> {}
class Bar2 : Foo<int> {}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Bar>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }
    [TestMethod]
    public async Task BoundWithUnboundGeneric() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>() where T : Foo<string, T> {
		
	}
}

interface Foo<TData,TData2>  {}
class Bar : Foo<string,Bar> {}

";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Bar>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }

    [TestMethod]
    public async Task MethodWithParameters() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>(string f1, int f2) where T : Foo<string, T> {
		
	}
}

interface Foo<TData,TData2>  {}
class Bar : Foo<string,Bar> {}

";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld(string f1, int f2) {
        GetHelloWorld<global::T1.T2.Bar>(f1, f2);
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }

    [TestMethod]
    public async Task MethodWithParamsParameters() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>(Guid f1, params int[] f2) where T : Foo<string, T> {
		
	}
}

interface Foo<TData,TData2>  {}
class Bar : Foo<string,Bar> {}

";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld(global::System.Guid f1, int[] f2) {
        GetHelloWorld<global::T1.T2.Bar>(f1, f2);
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }

    [TestMethod]
    public async Task InterfaceWithMultipleGenerics() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T,T2>() where T : Foo<T2, T> where T2 : System.Attribute {
		
	}
}

interface Foo<TData,TData2> where TData2 :  Foo<TData,TData2> {}
class Bar : Foo<System.FlagsAttribute,Bar> {}
class Bar2 : Foo<System.MTAThreadAttribute,Bar2> {}
class Bar3 : Foo<Object,Bar3> {}

";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Bar, global::System.FlagsAttribute>();
        GetHelloWorld<global::T1.T2.Bar2, global::System.MTAThreadAttribute>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }
    [TestMethod]
    public async Task InterfaceWithMultipleGenericsInvalid() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T,T2>()  {
		
	}
}

interface Foo<TData,TData2> where TData2 :  Foo<TData,TData2> {}
class Bar : Foo<System.FlagsAttribute,Bar> {}
class Bar2 : Foo<System.MTAThreadAttribute,Bar2> {}
class Bar3 : Foo<Object,Bar3> {}

";


        await VerifyCS.VerifyGeneratorAsync(code, DiagnosticResult.CompilerError("IG0001").WithSpan(7, 34, 7, 40), stdAttrributes
            );
    }

    [TestMethod]
    public async Task InvokeExternal() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke(ScanExternalAssamblies = true)]
	public static void GetHelloWorld<T>() where T : System.Collections.Stack {
		
	}
}



";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::System.Collections.Stack>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }

    [TestMethod]
    public async Task Freeze() {
        string code = @"
using System;
namespace T1.T2;
internal partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	 private void GetView<View, VM, OfFile>()
    where OfFile : class, IProjectItemContent<OfFile>
    where VM : IViewModel<OfFile, VM>
    where View : IView<OfFile, VM, View> {
		
	}
}


internal interface IViewModel<OfFile, ViewModel>
    where OfFile : class, IProjectItemContent<OfFile>
    where ViewModel : IViewModel<OfFile, ViewModel> {
}
internal interface IView<OfFile, VM, View>
    where OfFile : class, IProjectItemContent<OfFile>
    where VM : IViewModel<OfFile, VM>
    where View :  IView<OfFile, VM, View> {
}
internal interface IProjectItemContent<T> : IProjectItemContent where T : class, IProjectItemContent<T> {}
internal interface IProjectItemContent  { }

public sealed partial class TileSetEditor :  IView<TileSetFile, TileSetViewModel, TileSetEditor> {}
internal class TileSetViewModel : IViewModel<TileSetFile, TileSetViewModel> {}

internal partial class TileSetFile : IProjectItemContent<TileSetFile> {}

";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private void GetView() {
        GetView<global::T1.T2.TileSetEditor, global::T1.T2.TileSetViewModel, global::T1.T2.TileSetFile>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetView.g.cs", global)]
            );
    }

    [TestMethod]
    public async Task GenerateEnum() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter {
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>() where T : struct, System.Enum {
		
	}
}

enum Foo { Test }
class Bar {}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Foo>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }

    [TestMethod]
    public async Task TestFileScopedSciped() {
        string code = @"
using System;
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter {
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>()  {
		
	}
}

class Foo {}
file class Bar {}


";

        string global = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Foo>();
    }
}
";
        await VerifyCS.VerifyGeneratorAsync(code, [ ..stdAttrributes,
            ("T1.T2.class.GetHelloWorld.g.cs", global)]
            );
    }

}
