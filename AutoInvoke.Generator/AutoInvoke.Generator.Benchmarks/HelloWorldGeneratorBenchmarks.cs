using BenchmarkDotNet.Attributes;
using F0.CodeAnalysis.CSharp.Benchmarking;

namespace AutoInvoke.Generator.Benchmarks
{
	public class HelloWorldGeneratorBenchmarks
	{
		private readonly CSharpIncrementalGeneratorBenchmark<InvokeGenerator> benchmark = new();

		[GlobalSetup]
		public void Setup()
		{
			string code = @"
namespace T1.T2;
internal static partial class GlobalNamespaceGreeter
{
	[AutoInvoke.FindAndInvoke]
	public static void GetHelloWorld<T>() where T : Foo {
		
	}
}

class Foo {}
class Bar :Foo {}


";

			benchmark.Initialize(new CSharpIncrementalGeneratorBenchmarkInitializationContext
			{
				Source = code,
			});
		}

		[Benchmark]
		public object Generate()
		{
			return benchmark.Invoke();
		}

		[GlobalCleanup]
		public void Cleanup()
		{
			string attribute = @"// <auto-generated/>
#nullable enable

namespace AutoInvoke;
[System.AttributeUsage(System.AttributeTargets.Method, Inherited = false, AllowMultiple = true)]
[System.Diagnostics.Conditional(""AutoNotifyGenerator_DEBUG"")]
internal sealed class FindAndInvokeAttribute : System.Attribute
{
#pragma warning disable CS0169 // Remove unused parameter

#pragma warning disable IDE0060 // Remove unused parameter

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

    public FindAndInvokeAttribute()
    {
    }

    public FindAndInvokeAttribute(string pattern)
    {
    }

    public bool ScanExternalAssamblies { get; set; }
    public string MethodName { get; set; }
    public bool CallForAbstractClasses { get; set; }
    public bool CallForInterfaces { get; set; }
    public bool CallForStructs { get; set; }
    public bool CallForClasses { get; set; }
    public bool CallForRecords { get; set; }
    public bool CallForEnums { get; set; }
#pragma warning restore CS0169 // Remove unused parameter

#pragma warning restore IDE0060 // Remove unused parameter

#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

}";

		string generated = @"// <auto-generated/>
#nullable enable
namespace T1.T2;
partial class GlobalNamespaceGreeter {
    private static void GetHelloWorld() {
        GetHelloWorld<global::T1.T2.Foo>();
        GetHelloWorld<global::T1.T2.Bar>();
    }
}
";

			benchmark.Inspect(new CSharpIncrementalGeneratorBenchmarkInspectionContext
			{
				Source = ("attribute.g.cs", attribute),
				AdditionalSources = { ("T1.T2.class.GetHelloWorld.g.cs", generated) },
			});
		}
	}
}
